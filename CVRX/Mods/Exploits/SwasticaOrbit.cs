using ABI.CCK.Components;
using BTKUILib;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace CVRX.Mods.Exploits
{
    internal class SwasticaOrbit
    {
        public static List<CVRPickupObject> items = new List<CVRPickupObject>();
        public static Transform transform;
        public static bool _blind = false;
        public static bool _instance = false;
        public static bool _itemOrbit;
        public static bool _swastika;
        public static GameObject _targetItem;
        internal static Vector3 _setLocation;
        public static float _swastikaSize = 45f;
        public static float _hasTakenOwner = 1999f;
        public static float _setMultiplier = 160f;
        public static float _rotateState;
        public static Vector3 _originalVelocity;
        public static bool _returnedValue;
        public static void State(bool s)
        {
            if (s)
            {
                items = Resources.FindObjectsOfTypeAll<CVRPickupObject>().Where(i => i != null && !i.name.ToLower().Contains("quickmenu")).ToList();
                if (items.Count == 0)
                {
                    XConsole.Log("Exploits", "SwasticaOrbit: No valid items found.");
                    return;
                }
                transform = QuickMenuAPI.SelectedPlayerEntity.PlayerGameObject.transform;
                _swastika = true;
            }
            else
            {
                _swastika = false;
                items.Clear();
            }
        }
        public static void OnUpdate()
        {
            try
            {
                if (!_swastika)
                {
                    if (_returnedValue)
                    {
                        foreach (var item in items)
                        {
                            item.GetComponent<Rigidbody>().velocity = _originalVelocity;
                        }
                        _returnedValue = true;
                    }
                    return;
                }

                if (transform != null)
                {
                    Vector3 bonePosition = transform.position;
                    _setLocation = new Vector3(bonePosition.x, bonePosition.y + 2f, bonePosition.z);
                }

                if (Input.GetKeyDown(KeyCode.UpArrow)) _swastikaSize += 2f;
                if (Input.GetKeyDown(KeyCode.DownArrow)) _swastikaSize -= 2f;

                _rotateState = (_rotateState >= 360f) ? Time.deltaTime : _rotateState + Time.deltaTime;

                if (_hasTakenOwner >= 90f)
                {
                    _hasTakenOwner = 0f;
                }
                else
                {
                    _hasTakenOwner += 1f;
                }
                int totalItems = items.Count;
                float itemGroupCount = totalItems / 8f;
                float spacing = totalItems / _swastikaSize;

                for (int i = 0; i < totalItems; i++)
                {
                    var pickup = items[i];
                    int groupIndex = i / 8;
                    int armIndex = i % 8;
                    float ratio = groupIndex / itemGroupCount;

                    Vector3 offset = Vector3.zero;

                    switch (armIndex)
                    {
                        case 0:
                            offset = new Vector3(0f, spacing * ratio, 0f);
                            break;
                        case 1:
                            offset = new Vector3(0f, -spacing * ratio, 0f);
                            break;
                        case 2:
                            offset = new Vector3(-Mathf.Cos(_rotateState) * spacing * ratio, 0f, Mathf.Sin(_rotateState) * spacing * ratio);
                            break;
                        case 3:
                            offset = new Vector3(-Mathf.Cos(_rotateState + _setMultiplier) * spacing * ratio, 0f, Mathf.Sin(_rotateState + _setMultiplier) * spacing * ratio);
                            break;
                        case 4:
                            offset = new Vector3(-Mathf.Cos(_rotateState + _setMultiplier) * spacing, spacing * ratio, Mathf.Sin(_rotateState + _setMultiplier) * spacing);
                            break;
                        case 5:
                            offset = new Vector3(-Mathf.Cos(_rotateState) * spacing, -spacing * ratio, Mathf.Sin(_rotateState) * spacing);
                            break;
                        case 6:
                            offset = new Vector3(-Mathf.Cos(_rotateState + _setMultiplier) * spacing * ratio, -spacing, Mathf.Sin(_rotateState + _setMultiplier) * spacing * ratio);
                            break;
                        default:
                            offset = new Vector3(-Mathf.Cos(_rotateState) * spacing * ratio, spacing, Mathf.Sin(_rotateState) * spacing * ratio);
                            break;
                    }

                    pickup.transform.position = _setLocation + offset;
                    pickup.GetComponent<Rigidbody>().velocity = Vector3.zero;
                    pickup.transform.rotation = Quaternion.Euler(0f, _rotateState * -90f, 0f);
                }

            }
            catch (Exception ex)
            {
                XConsole.Log("Exploits", ex.Message);
                _swastika = false;
                transform = null;
            }
        }
    }
}
